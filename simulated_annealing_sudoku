import random
import math

def print_grid(grid):
    for row in grid:
        print(" ".join(str(num) for num in row))
    print()

def calculate_conflicts(grid):
    conflicts = 0
    size = len(grid)
    for i in range(size):
        row_counts = [0] * size
        col_counts = [0] * size
        box_counts = [[0] * size for _ in range(3)]
        
        for j in range(size):
            # Count row
            if grid[i][j] != 0:
                row_counts[grid[i][j] - 1] += 1
                if row_counts[grid[i][j] - 1] > 1:
                    conflicts += 1
            
            # Count column
            if grid[j][i] != 0:
                col_counts[grid[j][i] - 1] += 1
                if col_counts[grid[j][i] - 1] > 1:
                    conflicts += 1
            
            # Count 3x3 box
            box_row = (i // 3) * 3 + (j // 3)
            box_col = (i % 3) * 3 + (j % 3)
            if grid[box_row][box_col] != 0:
                box_counts[box_row // 3][box_col % 3] += 1
                if box_counts[box_row // 3][box_col % 3] > 1:
                    conflicts += 1
    
    return conflicts

def random_sudoku_state(initial_grid):
    grid = [row[:] for row in initial_grid]
    for i in range(len(grid)):
        for j in range(len(grid[i])):
            if grid[i][j] == 0:  # Empty cell
                grid[i][j] = random.randint(1, 9)
    return grid

def neighbor(grid):
    new_grid = [row[:] for row in grid]
    empty_cells = [(i, j) for i in range(9) for j in range(9) if new_grid[i][j] == 0]
    if not empty_cells:
        return new_grid
    i, j = random.choice(empty_cells)
    new_grid[i][j] = random.randint(1, 9)
    return new_grid

def simulated_annealing_sudoku(initial_grid, initial_temp, cooling_rate):
    current_grid = random_sudoku_state(initial_grid)
    current_conflicts = calculate_conflicts(current_grid)
    temperature = initial_temp

    while temperature > 1:
        new_grid = neighbor(current_grid)
        new_conflicts = calculate_conflicts(new_grid)

        if new_conflicts < current_conflicts:
            current_grid, current_conflicts = new_grid, new_conflicts
        else:
            acceptance_probability = math.exp((current_conflicts - new_conflicts) / temperature)
            if random.random() < acceptance_probability:
                current_grid, current_conflicts = new_grid, new_conflicts

        temperature *= cooling_rate

    return current_grid

def main():
    initial_grid = [
        [5, 3, 0, 0, 7, 0, 0, 0, 0],
        [6, 0, 0, 1, 9, 5, 0, 0, 0],
        [0, 9, 8, 0, 0, 0, 0, 6, 0],
        [8, 0, 0, 0, 6, 0, 0, 0, 3],
        [4, 0, 0, 8, 0, 3, 0, 0, 1],
        [7, 0, 0, 0, 2, 0, 0, 0, 6],
        [0, 6, 0, 0, 0, 0, 2, 8, 0],
        [0, 0, 0, 4, 1, 9, 0, 0, 5],
        [0, 0, 0, 0, 8, 0, 0, 7, 9]
    ]
    initial_temp = 1000
    cooling_rate = 0.995

    solution = simulated_annealing_sudoku(initial_grid, initial_temp, cooling_rate)
    print("Solved Sudoku Grid:")
    print_grid(solution)
    print("Conflicts:", calculate_conflicts(solution))

if __name__ == "__main__":
    main()

Solved Sudoku Grid:
5 3 3 6 7 3 6 8 6
6 7 4 1 9 5 8 2 9
7 9 8 8 4 1 1 6 3
8 3 6 6 6 5 4 7 3
4 5 7 8 5 3 9 1 1
7 1 5 6 2 2 9 5 6
4 6 2 9 1 9 2 8 5
3 5 1 4 1 9 3 9 5
5 9 5 2 8 8 4 7 9

Conflicts: 100
